#!/usr/bin/env ruby
require_relative './lib/option_parser.rb'
require_relative './lib/manager.rb'
require_relative './lib/helpers.rb'
require_relative './lib/webserver.rb'
class Main
  def initialize
    args = ARGV.clone
    ENV["RUBYLIB"] = "#{File.dirname(__FILE__)}/lib"
    Signal.trap("SIGPIPE") do
      Helper.lock_mg(:UNLOCK, args)
      exit
    end
    # Helper.check_environment(args)
    Helper.lock_mg(:LOCK, args)

    begin
      opt = OptionParser::OptionParser.new
      option_parser_default_initializer(opt)
      option_parser_conditions_initializer(opt)
      Helper.lock_mg(:UNLOCK, args)
    rescue SignalException
      Helper.lock_mg(:UNLOCK, args)
      exit -1
    rescue Exception => e
      puts e
      Helper.lock_mg(:UNLOCK, args)
      exit -1
    rescue Interrupt
      Helper.lock_mg(:UNLOCK, args)
      exit -1
    rescue EPIPE
      Helper.lock_mg(:UNLOCK, args)
      exit -1
    end
  end

  def option_parser_conditions_initializer(opt)
    # sources get
    opt.condition_option("sources get",     { name: "task", multiple: true } )
    opt.condition_option("sources get",     { name: "single_branch", short: "-s", type: :option } )
    opt.condition_action("sources get")     { |opts| puts "#{opts[:task]}, #{opts[:single_branch]}" }
    # sources delete
    opt.condition_option("sources delete",  { name: "task", mandatory: true } )
    opt.condition_action("sources delete")  { |opts| Source.delete_sources(opts[:task]) }
    # sources list
    opt.condition_action("sources list")    { |opts| Source.list_sources() }
    # sources show
    opt.condition_action("sources show")    { |opts| Source.show_sources() }
    # saveconfig
    opt.condition_option("saveconfig",      { name: "pathtosave", mandatory: true } )
    opt.condition_action("saveconfig")      { |opts| Config.save_config(opts[:pathtosave]) }
    # clone
    opt.condition_help("clone",             "Clone an existing Framework Environment to a directory")
    opt.condition_option("clone",           { name: "gitrepo", mandatory: true } )
    opt.condition_option("clone",           { name: "directory", mandatory: true } )
    opt.condition_action("clone")           { |opts| GitManager.get_clone_framework(opts[:gitrepo], opts[:directory]) }
    # init
    opt.condition_help("init",              "Create a new Framework Environment")
    opt.condition_option("init",            { name: "folderpath", mandatory: true } )
    opt.condition_action("init")            { |opts| Config.init_bsf(opts[:folderpath]) }
    # vars
    opt.condition_action("vars")            { |opts| VarManager.instance.var_list() }
    # tasks
    opt.condition_help("tasks",             "Lists all the tasks and its description")
    opt.condition_action("tasks")           { |opts| puts Manager.instance.tasks_list() }
    # set
    opt.condition_option("set",             { name: "var=value", type: :equal, mandatory: true } )
    opt.condition_action("set")             { |opts| VarManager.instance.set(opts[:var=value][0], opts[:var=value][1]); VarManager.instance.save }
    # execute
    opt.condition_option("execute",         { name: "confirm", short: "-y", type: :option } )
    opt.condition_option("execute",         { name: "parallel", short: "-p", type: :option } )
    opt.condition_option("execute",         { name: "task", mandatory: true, multiple: true } )
    opt.condition_action("execute")         { |opts| Manager.instance.build(opts[:task], opts[:confirm]) }
    # publish
    opt.condition_action("publish")         { |opts| Manager.instance.publish() }
    # diff
    opt.condition_option("diff",            { name: "hash1", mandatory: true })
    opt.condition_option("diff",            { name: "hash2", mandatory: true })
    opt.condition_action("diff")            { |opts| puts Manager.instance.diff(opts[:hash1], opts[:hash2]) }
    # git
    opt.condition_option("git",             { name: "gitcommand", mandatory: true, multiple: true } )
    opt.condition_action("git")             { |opts| GitManager.internal_git(opts[:gitcommand]) }
    # search  $<options>
    opt.condition_option("git",             { name: "options", mandatory: true, multiple: true } )
    opt.condition_action("search")          { |opts| puts GitManager.search_log(opts[:options]) }
    # compare
    opt.condition_option("compare",         { name: "task", mandatory: true } )
    opt.condition_option("compare",         { name: "args", mandatory: true, multiple: true, type: :args} )
    opt.condition_action("compare")         { |opts| puts Manager.instance.compare(opts[:task], opts[:args]) }
    # compare all
    opt.condition_option("compareall",      { name: "args", mandatory: true, multiple: true, type: :args} )
    opt.condition_action("compareall")      { |opts| puts Manager.instance.agregator(opts[:args]) }
    # report
    opt.condition_option("report",          { name: "task", mandatory: true } )
    opt.condition_option("report",          { name: "args", multiple: true, type: :args} )
    opt.condition_action("report")          { |opts| puts Manager.instance.report(opts[:task], opts[:args]) }
    # server
    opt.condition_option("server",          { name: "options", multiple: true, type: :args} )
    opt.condition_action("server")          { |opts| WebServer.execute(opts[:options]) }
    # log
    opt.condition_option("log",             { name: "follow", short: "-f", type: :option })
    opt.condition_option("log",             { name: "task", mandatory: true })
    opt.condition_option("log",             { name: "hash" })
    opt.condition_action("log")             { |opts| puts Manager.instance.log(opts[:task], opts[:hash], opts[:follow]) }
    # status
    opt.condition_option("status",          { name: "hash" })
    opt.condition_action("status")          { |opts| puts Manager.instance.status(opts[:hash]) }
    #clean
    opt.condition_option("clean",           { name: "confirm", short: "-y", type: :option })
    opt.condition_option("clean",           { name: "task", multiple: true } )
    opt.condition_action("clean")           { |opts| Manager.instance.clean(opts[:task], opts[:y]) }
    # ls
    opt.condition_option("ls",              { name: "task", mandatory: true } )
    opt.condition_option("ls",              { name: "hash" } )
    opt.condition_action("ls")              { |opts| puts Manager.instance.ls(opts[:task], opts[:commit_id]) }
    # cat
    opt.condition_option("cat",             { name: "task", mandatory: true } )
    opt.condition_option("cat",             { name: "file", mandatory: true } )
    opt.condition_option("cat",             { name: "hash" } )
    opt.condition_action("cat")             { |opts| puts Manager.instance.cat(opts[:task], opts[:commit_id], opts[:file]) }

    opt.parse(ARGV)

    # opt.condition("sources get {-s} ${name}")               { |opts| Source.get_sources(opts[:name], opts[:s]) }
    # opt.condition("sources delete <name>")                  { |opts| Source.delete_sources(opts[:name]) }
    # opt.condition("sources list")                           { |opts| Source.list_sources() }
    # opt.condition("sources show")                           { |opts| Source.show_sources() }
    # opt.condition("saveconfig <pathtosave>")                { |opts| Config.save_config(opts[:pathtosave]) }
    # opt.condition("clone <gitrepo> <dir>")                  { |opts| GitManager.get_clone_framework(opts[:gitrepo], opts[:dir]) }
    # opt.condition("init <folderpath>")                      { |opts| Config.init_bsf(opts[:folderpath]) }
    # opt.condition("vars")                                   { |opts| VarManager.instance.var_list() }
    # opt.condition("tasks")                                  { |opts| puts Manager.instance.tasks_list() }
    # opt.condition("set <var>=<value>")                      { |opts| VarManager.instance.set(opts[:var], opts[:value]); VarManager.instance.save }
    # opt.condition("execute {-y} ${task}")                   { |opts| Manager.instance.build(opts[:task], opts[:y]) }
    # opt.condition("publish")                                { |opts| Manager.instance.publish() }
    # opt.condition("diff <hash1> {hash2}")                   { |opts| puts Manager.instance.diff(opts[:hash1], opts[:hash2]) }
    # opt.condition("git $<gitcommand>")                      { |opts| GitManager.internal_git(opts[:gitcommand]) }
    # opt.condition("search $<search>")                  	    { |opts| puts GitManager.search_log(opts[:search]) }
    # opt.condition("compare all $<args>")    		            { |opts| puts Manager.instance.agregator(opts[:args]) }
    # opt.condition("compare <task> $<args>")    		          { |opts| puts Manager.instance.compare(opts[:task], opts[:args]) }
    # opt.condition("report <task> ${args}")                  { |opts| puts Manager.instance.report(opts[:task], opts[:args]) }
    # opt.condition("server ${options}")                      { |opts| WebServer.execute(opts[:options]) }
    # opt.condition("log {-f} <task> {hash}")                 { |opts| puts Manager.instance.log(opts[:task], opts[:hash], opts[:f]) }
    # opt.condition("status {hash} ")                         { |opts| puts Manager.instance.status(opts[:hash]) }
    # opt.condition("clean {-y} ${task}")                     { |opts| Manager.instance.clean(opts[:task], opts[:y]) }
    # opt.condition("ls <task> {commit_id}")                  { |opts| puts Manager.instance.ls(opts[:task], opts[:commit_id]) }
    # opt.condition("cat <task> <file> {commit_id}")          { |opts| puts Manager.instance.cat(opts[:task], opts[:commit_id], opts[:file]) }

    # opt.parse(ARGV)
  end


  def option_parser_default_initializer(opt)

    opt.default do
      puts <<-EOF
usage: bsf <command>

These are the BSF commands used in various situations:

Start a working Environment
    init <folderpath>                  Create a new Framework Environment
    clone <gitrepo> <dir>              Clone an existing Framework Environment to a directory

Work with task/s
    execute ${task}                    Execute the task's execution instruction
    log {-f} <task>                    Print or follow the task's log
    status                             Lists the status of all tasks
    tasks                              Lists all the tasks and its description

Work with Input Variables
    set <var>=<value>                  Defines the value to the input variable
    vars                               Lists all the Input Variables and its value

Work with lists
    tasks                              Lists all the tasks and its description
    vars                               Lists all Input Variables

Work with the Git Repositories
    sources get {-s} ${name}           Clone a new Source to the framework environment (-s for single branch)
    sources delete <name>              Delete a Source from the framework environment
    sources list                       List all the Sources in the config file
    sources show                       Show all cloned the Sources in the framework environment

Work with Git
    git $<gitcommand>                  Execute internal git commands
    publish                            Adds and commits with a specific commit message to local git repository
    search $<var>=<value>              Searchs on git log's commit message
    diff <hash1> <hash2>               Find the differences in the commit messages between two commit ids
    ls <task> {commit_id}              List all files within persistent workspace
    cat <task> <file> {commit_id}      Print a file from a task's persistent workspace

Work with comparasion
    compare <task> $<args>             Compares test from different commits
    compare all $<args>                Compares all tests from different commits

Work with reporting
    report <task> ${args}              Print a report on the given task

Extra commands
    saveconfig <pathtosave>            Saves internal config with dependencies to pathtosave
    clean {-y} ${task}                 Cleans workspace folder, logs and resets status



	{} Optional Argument		<> Mandatory Argument		$ Capable of multiple Arguments

EOF
    end
  end


end

Main.new
